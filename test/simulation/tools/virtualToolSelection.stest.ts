/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import assert from 'assert';
import { readFileSync } from 'fs';
import * as path from 'path';
import type { LanguageModelToolInformation } from 'vscode';
import { ToolName } from '../../../src/extension/tools/common/toolNames';
import { IToolGroupingService } from '../../../src/extension/tools/common/virtualTools/virtualToolTypes';
import { HARD_TOOL_LIMIT } from '../../../src/platform/configuration/common/configurationService';
import { ObjectJsonSchema } from '../../../src/platform/configuration/common/jsonSchema';
import { deserializeWorkbenchState } from '../../../src/platform/test/node/promptContextModel';
import { CancellationToken } from '../../../src/util/vs/base/common/cancellation';
import { isDefined } from '../../../src/util/vs/base/common/types';
import { LanguageModelToolMCPSource, LanguageModelToolResult } from '../../../src/vscodeTypes';
import { ssuite, stest } from '../../base/stest';
import { generateToolTestRunner } from '../../e2e/toolSimTest';

// Generated by copilot
class MersenneTwister {
	private readonly mt = new Array(624);
	private index = 0;

	constructor(seed: number) {
		this.mt[0] = seed >>> 0;
		for (let i = 1; i < 624; i++) {
			const s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
			this.mt[i] = (((((s & 0xffff0000) >>> 16) * 0x6c078965) << 16) + (s & 0x0000ffff) * 0x6c078965 + i) >>> 0;
		}
	}

	public nextInt() {
		if (this.index === 0) {
			this.generateNumbers();
		}

		let y = this.mt[this.index];
		y = y ^ (y >>> 11);
		y = y ^ ((y << 7) & 0x9d2c5680);
		y = y ^ ((y << 15) & 0xefc60000);
		y = y ^ (y >>> 18);

		this.index = (this.index + 1) % 624;

		return y >>> 0;
	}

	public nextIntRange(start: number, endExclusive: number) {
		const range = endExclusive - start;
		return Math.floor(this.nextInt() / (0x100000000 / range)) + start;
	}

	private generateNumbers() {
		for (let i = 0; i < 624; i++) {
			const y = (this.mt[i] & 0x80000000) + (this.mt[(i + 1) % 624] & 0x7fffffff);
			this.mt[i] = this.mt[(i + 397) % 624] ^ (y >>> 1);
			if ((y % 2) !== 0) {
				this.mt[i] = this.mt[i] ^ 0x9908b0df;
			}
		}
	}
}

ssuite.skip({ title: 'vscode', subtitle: 'virtualtool', location: 'panel' }, async (_) => {

	const allTools: {
		servers: {
			name: string;
			toolsets: {
				name: string;
				description: string;
				tools: {
					name: string;
					description: string;
					inputSchema: ObjectJsonSchema;
				}[];
			}[];
		}[];
	} = JSON.parse(readFileSync('../../../mcp-tool-router/python/src/server/data/mcp_servers.json', 'utf-8'));

	const maxOverallToolName = 64;
	const mcpServerPrefix = 'mcp_';
	const maxServerName = 18 - mcpServerPrefix.length;
	const maxToolName = maxOverallToolName - maxServerName - mcpServerPrefix.length - 1;

	function normalizeName(name: string, max: number) {
		return name.replace(/[^a-zA-Z0-9_]/g, '_').slice(0, max);
	}

	for (const server of allTools.servers) {
		server.name = normalizeName(server.name, maxServerName);
		for (const toolset of server.toolsets) {
			for (const tool of toolset.tools) {
				tool.name = normalizeName(tool.name, maxToolName);
			}
		}
	}

	const scenarios: {
		question: string;
		expected_tools: string[];
	}[] = JSON.parse(readFileSync('../../../mcp-tool-router/python/src/app/data/test_cases.json', 'utf-8'));

	const lmToolServers: { server: string; tools: LanguageModelToolInformation[] }[] = allTools.servers.map(server => ({
		server: server.name,
		tools: server.toolsets.flatMap(toolset => {
			return toolset.tools.map((tool): LanguageModelToolInformation => ({
				name: `mcp_${server.name}_${tool.name}`,
				description: tool.description,
				inputSchema: tool.inputSchema,
				tags: [],
				source: new LanguageModelToolMCPSource(server.name, server.name),
			}));
		}),
	}));

	for (const [i, { question, expected_tools }] of scenarios.slice(0, 250).entries()) {
		const rng = new MersenneTwister(i);
		if (expected_tools.some(e => e.startsWith('VSCode'))) {
			continue; // not an MCP server and would prefer our built-in tools
		}

		const neededServers = new Set<string>();
		const expected = expected_tools.map(tn => {
			const idx = tn.indexOf('.');
			const server = normalizeName(tn.substring(0, idx), maxServerName);
			const tool = normalizeName(tn.substring(idx + 1), maxToolName);
			neededServers.add(server);
			return `mcp_${server}_${tool}`;
		});

		const installedServers = lmToolServers.filter(s => neededServers.has(s.server));
		if (!installedServers.length) {
			throw new Error('unknown tools in ' + expected_tools.join(', '));
		}

		while (installedServers.length < 15) {
			const next = lmToolServers[rng.nextIntRange(0, lmToolServers.length)];
			if (!installedServers.includes(next)) {
				installedServers.push(next);
			}
		}

		const scenarioFolder = path.join(__dirname, '..', 'test/scenarios/test-tools');
		const getState = () => deserializeWorkbenchState(scenarioFolder, path.join(scenarioFolder, 'chatSetup.state.json'));

		stest({ description: `${i}: ${question}` }, async (accessor) => {
			const myAccessor = accessor.clone().createTestingAccessor();
			const toolGrouping = myAccessor.get(IToolGroupingService);
			const grouping = toolGrouping.create(installedServers.flatMap(s => s.tools));

			const computed = await grouping.compute(CancellationToken.None);
			assert(computed.length < HARD_TOOL_LIMIT, 'expected to generate less than the limit of tools');

			const containers = expected
				.map(e => grouping.getContainerFor(e))
				.filter(isDefined)
				.filter(c => c.isExpanded === false);
			if (!containers.length) {
				return; // already auto-expanded, nothing to do
			}

			await generateToolTestRunner({
				question,
				scenarioFolderPath: '',
				getState,
				tools: Object.fromEntries(computed.map(c => [c.name, true])),
				expectedToolCalls: { anyOf: containers.map(c => c.name as ToolName) }
			}, {
				allowParallelToolCalls: true,
				toolOverrides: new Map(computed.map(c => [c, {
					invoke() {
						return new LanguageModelToolResult([]);
					}
				}])),
			})(accessor);
		});
	}

});
